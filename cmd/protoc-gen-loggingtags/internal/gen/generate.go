package gen

import (
	"bytes"
	"go/format"
	"html/template"
	"strings"
	"unicode"

	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/heroku/x/loggingtags"
)

var tmpl = `
// Code generated by protoc-gen-loggingtags. DO NOT EDIT.

package {{.PackageName}}

import (
	"time"

	"github.com/golang/protobuf/ptypes"
	dpb "github.com/golang/protobuf/ptypes/duration"
	tspb "github.com/golang/protobuf/ptypes/timestamp"
)

{{- range .Messages}}
// LoggingTags returns loggable fields as key-value pairs.
func (r *{{.Name}}) LoggingTags() map[string]interface{} {
    if r == nil {
        return map[string]interface{}{}
    }
    return map[string]interface{}{
{{- range .Fields}}
  {{- if eq .TypeName ".google.protobuf.Timestamp"}}
        "{{.Name}}": loggingTagsTimestamp(r.{{.CamelName}}),
  {{- else if eq .TypeName ".google.protobuf.Duration"}}
        "{{.Name}}": loggingTagsDuration(r.{{.CamelName}}),
  {{- else}}
        "{{.Name}}": r.{{.CamelName}},
  {{- end}}
{{- end}}
    }
}
{{- end}}

func loggingTagsTimestamp(ts *tspb.Timestamp) time.Time {
	t, _ := ptypes.Timestamp(ts)
	return t
}

func loggingTagsDuration(dur *dpb.Duration) time.Duration {
	d, _ := ptypes.Duration(dur)
	return d
}
`

type templateData struct {
	PackageName string
	Messages    []messageData
}

type messageData struct {
	Name   string
	Fields []fieldData
}

type fieldData struct {
	Name      string
	CamelName string
	TypeName  string
}

// Generate processes req to generate loggingtags code for files mapped to
// package names in pkgMap.
func Generate(req *plugin.CodeGeneratorRequest, pkgMap map[string]string) (*plugin.CodeGeneratorResponse, error) {
	files := make([]*plugin.CodeGeneratorResponse_File, 0, len(req.GetProtoFile()))
	for _, fdp := range req.GetProtoFile() {
		protoFilename := fdp.GetName()

		// Only generate loggingtags for files being generated.
		if protoFilename != req.FileToGenerate[0] {
			continue
		}

		t, err := template.New("loggingtags").Parse(tmpl)
		if err != nil {
			return nil, err
		}

		var msgs []messageData
		for _, dp := range fdp.GetMessageType() {
			var fields []fieldData
			for _, f := range dp.GetField() {
				allow := false
				opts := f.GetOptions()
				if opts != nil && proto.HasExtension(opts, loggingtags.E_Safe) {
					allow = true
				}
				if allow {
					fields = append(fields, fieldData{
						Name:      f.GetName(),
						CamelName: toCamelCase(f.GetName()),
						TypeName:  f.GetTypeName(),
					})
				}
			}
			if len(fields) == 0 {
				continue
			}

			msgs = append(msgs, messageData{
				Name:   dp.GetName(),
				Fields: fields,
			})
		}

		if len(msgs) == 0 {
			continue
		}

		pkg := fdp.GetPackage()

		data := templateData{
			PackageName: pkg,
			Messages:    msgs,
		}
		buf := &bytes.Buffer{}
		if err := t.Execute(buf, data); err != nil {
			return nil, err
		}
		filename := strings.Replace(protoFilename, ".proto", ".pb.loggingtags.go", 1)
		code := buf.String()
		formatted, err := format.Source([]byte(code))
		if err != nil {
			return nil, err
		}

		files = append(files, &plugin.CodeGeneratorResponse_File{
			Name:    proto.String(filename),
			Content: proto.String(string(formatted)),
		})
	}

	features := uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	resp := &plugin.CodeGeneratorResponse{
		File:              files,
		SupportedFeatures: &features,
	}
	return resp, nil
}

func toCamelCase(str string) string {
	split := func(c rune) bool {
		return unicode.IsSpace(c) || unicode.IsPunct(c)
	}
	s := strings.FieldsFunc(str, split)
	cc := make([]string, len(s))

	for _, word := range s {
		cc = append(cc, strings.Title(word))
	}

	return strings.Join(cc, "")
}
